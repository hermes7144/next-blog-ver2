순수 함수는 계산만 수행하고 그 이상은 수행하지 않습니다. 컴포넌트를 엄격하게 순수 함수로만 작성하면 코드베이스가 커짐에 따라 당황스러운 버그와 예측할 수 없는 동작을 피할 수 있습니다. 이러한 이점을 얻으려면 몇 가지 규칙을 준수해야 합니다.

## 순수성: 수식으로서의 컴포넌트

컴퓨터 과학(특히 함수형 프로그래밍의 세계)에서 순수 함수는 다음과 같은 특징을 가진 함수입니다.

- **자신의 일에만 신경씁니다.** 호출되기 전에 존재했던 객체나 변수를 변경하지 않습니다.
- **동일 입력, 동일 출력.** 동일한 입력이 주어지면 항상 동일한 결과를 반환해야 합니다.

React는 이 개념을 중심으로 설계되었습니다. **React는 작성하는 모든 컴포넌트가 순수 함수라고 가정합니다.** 즉, 여러분이 작성하는 React 컴포넌트는 동일한 입력이 주어졌을 때 항상 동일한 JSX를 반환해야 합니다.

컴포넌트를 레시피라고 생각할 수 있습니다. 레시피를 따르고 요리 과정에 새로운 재료를 넣지 않으면 매번 같은 요리를 얻을 수 있습니다. 그 "요리"는 컴포넌트가 렌더링에 반응하기 위해 제공하는 JSX입니다.

## 사이드이펙트:(un)intended consequences

React의 렌더링 프로세스는 항상 순수해야 합니다. 컴포넌트는 오직 JSX만을 반환해야 하며, 렌더링 전에 존재했던 객체나 변수를 변경해서는 안 됩니다. 이는 컴포넌트를 비순수하게 만들 수 있습니다!

일반적으로 컴포넌트가 특정 순서로 렌더링될 것이라고 기대해서는 안됩니다. y = 2x를 y = 5x 앞에 호출하든 뒤에 호출하든 상관없습니다. 두 수식은 서로 독립적으로 해결됩니다. 마찬가지로 각 컴포넌트는 렌더링 중에 다른 컴포넌트와 조율하거나 의존하지 말고 "스스로 생각"하게 해야 합니다. 렌더링은 학교 시험처럼 각 컴포넌트가 스스로 JSX를 계산하게 해야 합니다!

> React에서는 렌더링하는 동안 읽을 수 있는 입력이 세 가지 있습니다. props, state, context. 이러한 입력은 항상 읽기 전용으로 취급해야 합니다.
> 사용자 입력에 대한 응답으로 무언가를 변경하려면 변수에 쓰는 대신 state를 설정해야 합니다. 컴포넌트가 렌더링되는 동안에는 기존 변수나 객체를 절대 변경해서는 안됩니다.
> React는 개발 환경에서 각 컴포넌트의 함수를 두 번 호출하는 "Strict Mode"를 제공합니다. Strict Mode는 컴포넌트 함수를 두 번 호출함으로써 이러한 규칙을 위반하는 컴포넌트를 찾아내는 데 도움이 됩니다.
> **순수 함수는 계산만 하므로 두 번 호출해도 아무것도 바뀌지 않습니다.**

## 지역 변이: 컴포넌트의 작은 비밀

컴포넌트가 렌더링하는 동안 기존 변수를 변경하는 것이 문제였다. 이를 좀 더 무섭게 들리기 하기 위해 **"변이"**라고 부르기도 합니다. 순수 함수는 함수의 범위를 벗어난 변수나 호출 전에 생성된 객체를 변이하지 않습니다. 그러면 순수하지 않으니까요!

하지만 **렌더링하는 동안 '방금' 생성한 변수와 객체를 변경하는 것은 완전히 괜찮습니다.** 이 예제에서는 `[]`배열을 생성하고 이를 `cups` 변수에 할당한 다음 컵 12개를 그 안에 `push`합니다.

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = i; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

`cups` 변수나 `[]` 배열이 `TeaGathering` 함수 외부에서 생성되었다면 큰 문제가 될 것입니다. 해당 배열에 항목을 밀어 넣음으로써 _기존_ 객체를 변경하게 될 것이기 때문입니다.

하지만 `TeaGathering` 내부에서 동일한 렌더링 중에 생성했기 때문에 괜찮습니다. `TeaGathering` 외부의 어떤 코드도 이런 일이 일어났다는 것을 알 수 없습니다. 이를 **지역 변이**라고 하며, 컴포넌트의 작은 비밀과 같습니다.

## 사이드 이펙트를 일으킬 수 있는 곳

함수형 프로그래밍은 순수성에 크게 의존하지만, 어느 시점에서는 어딘가에서 무언가가 바뀌어야 합니다. 이것이 바로 프로그래밍의 핵심입니다! 화면 업데이트, 애니메이션 시작, 데이터 변경과 같은 이러한 변경을 **사이드 이펙트**라고 하며, 렌더링 중에 일어나는 것이 아니라 "부수적으로" 일어나는 일입니다.

React에서 **사이드 이펙트는 보통 이벤트 핸들러에 속합니다.** 이벤트 핸들러는 사용자가 어떤 동작을 수행할 때(예를 들어, 버튼을 클릭할 때) React가 실행되는 함수입니다. 이벤트 핸들러가 컴포넌트 내부에 정의되어 있긴 하지만 렌더링 중에는 실행되지 않습니다! **따라서 이벤트 핸들러는 순수할 필요가 없습니다.**
다른 옵션을 다 사용했는데도 사이드 이펙트에 적합한 이벤트 핸들러를 찾을 수 없다면, 컴포넌트에서 `useEffect` 호출을 통해 반환된 JSX에 이벤트 핸들러를 첨부할 수 있습니다. 이렇게 하면 나중에 렌더링 후 사이드 이펙트가 허용될 때 React가 이를 실행하도록 지시합니다. **하지만 이 방법은 최후의 수단으로 사용해야 합니다.**

> ### React가 순수성을 중요시하는 이유
>
> 입력이 변경되지 않은 컴포넌트는 렌더링 건너뛰기(memo?)를 통해 성능을 향상시킬 수 있습니다. 순수 함수는 항상 동일한 결과를 반환하므로 캐싱해도 안전합니다.
> 깊은 컴포넌트 트리를 렌더링하는 도중에 일부 데이터가 변경되면 React는 오래된 렌더링을 완료하기 위해 시간을 낭비하지 않고 렌더링을 다시 시작할 수 있습니다. 순수성 덕분에 언제든지 계산을 중단해도 안전합니다.
> 우리가 구축하는 모든 새로운 React 기능은 순수성의 이점을 활용합니다. 데이터 불러오기부터 애니메이션, 성능에 이르기까지, 컴포넌트를 순수하게 유지하면 React 패러다임의 힘을 발휘할 수 있습니다.
