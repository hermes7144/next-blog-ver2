자주하는 실수
화살표 함수는 `=>` 바로 뒤에 표현식을 암시적으로 반환하므로 `return`문이 필요하지 않습니다.

```jsx
const listItems = chemists.map(
  (person) => <li>...</li> // Implicit return!
);
```

그러나 `=>` 뒤에 `{` 중괄호가 오는 경우 `return`을 명시적으로 작성해야 합니다.

```jsx
const listItems = chemists.map(person => { // Curly brace
  ...
  return <li>...</li>;
})
```

`=> {` 가 포함된 화살표 함수는 "블록 본문"을 가져야합니다. 이 경우 한 줄 이상의 코드를 작성할 수 있지만, 반드시 직접 `return`문을 작성해야 합니다. `return`을 잊으면 아무것도 반환되지 않습니다!

> map()호출 내부의 JSX 요소에는 항상 key가 필요합니다!

### 목록의 각 항목에 여러 개의 DOM 노드 표시하기

짧은 `<>...</> Fragment` 구문으로는 key를 전달할 수 없으므로 단일 <div>로 그룹화하거나, <Fragment> 구문을 사용해야 합니다.

```jsx
import { Fragment } from 'react';

// ...

const listItems = people.map(person =>
  <Fragment key={person.id}>
    <h1>{person.name}<h1>
    <h1>{person.bio}<h1>
  </Fragment>
  );
```

Fragment는 DOM에서 사라지므로, `<h1>`, `<p>`, `<h1>`, `<p>` 등의 1차원 목록이 생성됩니다.

### 키를 얻을 수 있는 곳

- 데이터베이스의 데이터: 데이터베이스에서 데이터를 가져오는 경우, 고유한 데이터베이스 key/ID를 사용할 수 있습니다.
- 로컬에서 생성된 데이터: 데이터가 로컬에서 생성되고 유지되는 경우, 항목이 증가하는 카운터, uuid 같은 패키지를 사용하세요.

### Key 규칙

- **key는 형제간에 고유해야 합니다.** 다른 배열의 JSX 노드에는 동일한 key를 사용해도 괜찮습니다.
- **key가 변경되지 않아야 합니다.** 그렇지 않으면 목적에 어긋나게 됩니다.

## React에 key가 필요한 이유

key를 사용하면 형제 항목 사이에서 특정 항목을 고유하게 식별할 수 있습니다. 잘 선택한 key는 배열 내 위치보다 더 많은 정보를 제공합니다. 만약 재정렬로 인해 어떤 항목의 위치가 변경되더라도, 해당 항목이 사라지지 않는 한, React는 `key`를 통해 그 항목을 식별할 수 있습니다.

> 배열에서 항목의 인덱스를 key로 사용하고 싶을 수도 있다. key를 지정하지 않으면, React는 인덱스를 키로 사용한다. 그러나 렌더링한 항목의 순서는 새 항목이 삽입되거나, 삭제되거나, 배열의 순서가 바뀌는 등에 따라 변경될 수 있습니다. 인덱스를 key로 사용하면 종종 미묘하고 혼란스러운 버그가 발생합니다.
> 마찬가지로 key={Math.random()} 과 같이 즉석에서 key를 생성하지 마세요. 이렇게 하면 렌더링될 때마다 key가 일치하지 않아 매번 모든 컴포넌트와 DOM이 다시 생성됩니다. 속도가 느려질뿐만 아니라 목록 항목 내부의 사용자 입력도 손실됩니다. 대신 데이터에 기반한 안정적인 ID를 사용하세요.
